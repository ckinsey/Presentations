<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Inhereting a Sloppy Codebase:  A Practical Guide to Wrangling Chaotic Code</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/lofty.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
				    <h1>Inheriting a <br>Sloppy Codebase</h1>
				    <h2>A Practical Guide to Wrangling Chaotic Code</h2>
				</section>
				
				<section>
				    <section>
                        <h2>Casey Kinsey</h2>
                        <p>@cordiskinsey</p>
                        <p>github.com/ckinsey</p>
                    </section>
                    <section data-background="#34b6e6">
                        <div style="background: url(assets/lofty_logo_dark.png) center no-repeat; height: 300px;"></div>
                        <p>hirelofty.com</p>
                        <p>github.com/loftylabs</p>
                        <p>@loftylabs</p>
                    </section>
                    <section data-background="#222222">
                        <div style="background: url(assets/heapsort_darkbg.png) center no-repeat; background-size: 90%; height: 300px;"></div>
                        <p>heapsortjobs.com</p>
                        <p>@heapsortapp</p>
                    </section>
                    
                    <section>
                        <h2>Get These Slides</h2>
                        <p><a href="http://hirelofty.com/djangocon14">hirelofty.com/djangocon14</a></p>
                    </section>
				    
				</section>
				<section>
				    <h1>Inheriting a <br>Sloppy Codebase</h1>
				    <h2 class="fragment current-visible">A Practical Guide to Wrangling Chaotic Code</h2>
				    <h2 class="fragment">A Practical Guide to Wrangling <span style="color: #FF3333;">Contractor</span> Code</h2>
				</section>
				<section>
				    <section>
    				    <h2>Rapid prototyping is a lie.</h2>
    				    <p class="fragment">Or at least what we're calling "rapid prototyping".</p>
    				</section>
    				<section>
    				    <div style="float: left; width: 50%;">
    				        <img src="assets/tesla-model-s-prototype-leak-003_100197858_l.jpg" width="100%">
    				    </div>
    				    <div style="float: left; width: 50%;">
    				        <img src="assets/syncedin.png" width="100%">
    				    </div>
    				</section>
    				<section>
    				    <div style="float: left; width: 50%;">
    				        <img src="assets/2012-tesla-model-s-interior.jpg" width="100%">
    				    </div>
    				    <div style="float: left; width: 50%;">
    				        <img src="assets/syncedin.png" width="100%">
    				    </div>
    				</section>
    				<section>
    				      <img src="assets/diff.png" width="100%">
    				</section>
				</section>
				<section>
                    <h2>Don't justify bad code by calling it a "prototype"</h2>
                    <p>When you know damn well its going to get shipped into production</p>
				</section>
				<section>
				    <section>
        				<h2>You're Gonna Need Some Tools</h2>
        				<ul>
            				<li>A proper editor/IDE</li>
            				<li>Debuggers</li>
            				<li>Coverage.py</li>
            				<li>[PyLint]</li>
            				<li>[pep8]</li>
        				</ul>
        		    </section>
        		    <section>
        		        <h2>What makes a good<br> editor/IDE?</h2>
        		        <ul>
            		        <li>Allows you to navigate quickly through disorganized and unfamiliar code.</li>
            		        <li>Introspection and code completion will save you time and headaches.</li>
            		        <li>Many provide excellent refactoring tools.</li>
            		    </ul>

            		    <p class="fragment">
            		        <br><br>
            		        <strong>PyCharm, PyDev (Eclipse), emacs, and more</strong>
            		    </p>
                    </section>
        		    <section>
        		        <h2>Debuggers</h2>
        		        <p><strong style="color: #FF3333;">(Django Debug Toolbar Doesn't Count)</strong></p>
        		        <p>There will be much debugging. If you're not familiar with a Python debugger, choose one and get comfy with it.</p>
        		        <p class="fragment">
        		            <br><br>
        		            <strong>pdb, ipdb, pudb, and many more.</strong><br>
        		            <em>Bonus Points:</em> Have one integrated with your IDE.
        		        </p>
                    </section>
        		    <section>
        		        <h2>Coverage.py</h2>
        		        <p style="text-align: left">Its too easy to not be using it.</p>
        		        <pre><code>
$ coverage run manage.py test        		        
        		        </code></pre>
        		        <p style="text-align: left">Here's my goto command:</p>
        		        <pre><code>
$ coverage run manage.py test --exclude *migrations/ project/settings.py         		        
        		        </code></pre>
        		        <p  style="text-align: left">Generate a report:</p>
        		        <pre><code>
$ coverage report         		        
        		        </code></pre>
        		        
        		        
        		        <p>You'll use this very soon.</p>
                    </section>
        		    <section>
        		        <h2>Optionally, PyLint and pep8</h2>
                        <ul>
                            <li class="fragment">PyLint will help you clean up poorly structured code and unused dependencies.  It's also helpful during refactors.</li>
                            <li class="fragment">pep8 will keep your code legible for the next guy.  <span class="fragment" style="color: #FF3333;">It will also make you irreversibly anal.</span></li>
                        </ul>
                        <p class="fragment">
                            <br><br>
                            <em>Bonus Points:</em> Have these integrated with your IDE.
                        </p>
                    </section>
                </section>
                <section>
                    <h2>Cool.  You've just gotten <br>your first look at the sloppy codebase.</h2>
                </section>
                <section>
                    <h1>Don't.  Touch.  Anything.</h2>
                    <h2 class="fragment" style="color: #FF3333;"><em>Everything</em> is Hot Lava</h2>
                </section>
                
                <section>
                    <section>
                        <h1>You're Gonna Do Some Prep-work</h1>
                    </section>
                    <section>
                        <h2>Do this first</h2>
                        <pre><code>
$ git checkout -b original_project master
                        </code></pre>
                        <p>Now, when you want to see the way the code originally worked:</p>
                        <pre><code>
$ git diff original_project master -- myapp/models.py                        
                        </code></pre>
                        <p>And once everything is all cleaned up...  Your badge of honor:</p>
                        <pre><code>
$ git diff original_project..master --stat
                        </code></pre>
                    </section>
                    <section>
                        <h2>Fire it up</h2>
                        <p>Create a virtual environment.  But don't get attached to it.</p>
                        <p>The goal is to get the project running in its last known working configuration.</p>
                        <p>If the project shipped with a dependency list, use it. If not, you'll have to wing it.  Don't remove any dependencies--only install ones that are missing.</p>  
                        <p>If the project shipped with tests, try to get them running.  <em>Keep in mind that if the project is in disarray, there's a good chance that the test suite was not passing in its last known working state.</em></p>
                        <p>Be sure to freeze your dependencies into requirements.txt if you added new ones.<p>
                    </section>
                </section>
                <section>
                    <section>
                        <h1>You're Gonna Need Test<br>Coverage</h1>
                    </section>
                    <section>
                        <h2>We're not going to go too crazy here</h2>
                        <ul>
                            <li>Integration test coverage for all Django views.</li>
                            <li>Integration and or unit test coverage for business critical processes.</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Integration Tests</h2>
                        <p>For our purposes, an integration test end-to-end test of the Python/Django code.</p>
                        <p>Our goal is coverage, first and foremost.  We want to catch landmines and see that refactors in one module do not unexpectedly affect another.</p>
                    </section>
                    <section>
                        <h2>Integration Tests: An Example</h2>
                        <pre><code>
class HeapsortIntegrationTests(HeapsortIntegrationTestCase):

    def test_home_anon(self):
        """
        Tests the homepage view works for anonymous users
        """

        # Unauthenticated
        self.client.logout()
        response = self.client.get(reverse('home'))

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed('home.html')
                        </code></pre>
                    </section>
                    <section>
                        <h2>Unit Tests</h2>
                        <p>Our goal is not to achieve full unit test coverage.  Unit tests are tightly coupled to implementation and will be largely negated by refactoring.</p>
                    </section>
                    <section>
                        <h2>Unit Tests: An Example</h2>
                        <pre><code>
import unittest
import mock
import datetime

from job.models import Job

class JobUnitTests(unittest.TestCase):

    # ...
    
    def test_jobs_expire_after_30_days(self):
        """
        A job should no longer be returned by the manager when it expires
        """
        
        now = datetime.datetime.now()
        the_future = datetime.timedelta(days=30)

        datetime_mock = mock.Mock()

        with mock.patch.multiple('jobs.models', datetime=datetime_mock):

            datetime_mock.datetime.now.return_value = now
            
            # Create a job.  The job should be returned by the manager
            test_job = self._create_job("My Test Job")
            self.assertTrue(test_job in Job.active.all())
            
            # Fast-forard to... THE FUTURE
            datetime_mock.datetime.now.return_value = now + the_future
            self.assertFalse(test_job in Job.active.all())
                        </code></pre>
                    </section>
                    <section>
                        <h2>Test Coverage: How much is enough?</h2>
                        <ul>
                            <li>Integration test coverage for all Django views and user paths, management commands, 3rd party APIs.</li>
                            <li>Unit test coverage for business critical processes and non view-logic.
                                <ul>
                                    <li>Billing processes</li>
                                    <li>Transactional communication</li>
                                    <li>Asynchronous tasks</li>
                                </ul>
                            </li>
                            <li>Coverage.py > 90% should be easy. > 95% is ideal.  No individual files left uncovered.</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <h1>It's Time to Start Wrangling</h1>
                    <h2>There's No Telling What You'll Find</h2>
                </section>
                <section>
                    <section>
                        <h2>The Patchwork Quilt of Dependencies Project</h2>
                        <pre><code>
    $ git diff --stat original_initial_product development -- requirements.txt
     requirements.txt | 135 +------------------------------------------------------------------
     1 file changed, 2 insertions(+), 133 deletions(-)
                        </code></pre>
                    </section>
                    <section>
                        <h2>All Dependencies Introduce Complexities</h2>
                        <p>Whether or not to use a 3rd party module is a matter of determining if the ends justify the means</p>
                        <ul>
                            <li>Each dependency is a potential obstacle to upgrades.</li>
                            <li>Low-level Django extensions can conflict and make debugging a nightmare.</li>
                            <li>3rd party modules installed from VCS make no stability or availability guarantees.</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Trim the Fat</h2>
                        <p>Remember that virtual environment you created?</p>
                        <p>Good.  Now throw that shit away.</p>
                        <p>Install the absolute bare minimum of requirements you know you need. 
                        (Django, South, database drivers, APIs that drive core functionality)</p>
                    </section>
                    <section>
                        <h2>Audit each other requirement one-by-one</h2>
                        <p>Research each requirement and know exactly what it is, how it works, and why it is used.  They will fall into one of three categories.</p>
                        <ol>
                            <li>Totally unnecessary, or even unused.<ul>
                                <li>Remove these now.</li>
                            </ul></li>
                            <li>Potentially unnecessary, but requires refactoring to remove.<ul>
                                <li>Make a judgement call.  Remove these if the effort is low, or note them as part of larger refactoring tasks.</li>
                            </ul></li>
                            <li>Necessary functionality for the project.<ul>
                                <li>Leave these in place</li>
                            </ul></li>
                        </ol>
                    </section>
                    <section>
                        <h2>Test and Upgrade</h2>
                        <p>Run the tests!  If you missed something, go back to the previous step.</p>
                        <p>Once your tests are passing, this is the best time to upgrade packages.</p>
                        <p>Upgrade.  Test.  Repeat</p>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>The Monolithic App of Death</h2>
                        <p>One app to rule them all.</p>
                    </section>
                    <section>
                        <h2>The Monolithic App of Death</h2>
                        <p>Monoliths are an organizational nightmare.</p>
                        <ul>
                            <li>You cannot succinctly evaluate the functionality of any one component.</li>
                            <li>Nothing is portable.</li>
                            <li>Usually rife with <pre><code>from my_app import *</code></pre></li>
                        </ul>
                    </section>
                    <section>
                        <h2>Refactoring Monoliths</h2>
                        <ul>
                            <li>Create a sane app structure.<li>
                            <li>Clean up imports and let PyLint do its thing.<ul>
                                <li>With `import *` out of the picture, you can easily find all imports of a symbol.</li>
                            </ul></li>
                            <li>Migrate models to their new homes.<ul>
                                <li>Everything else will follow.</li>
                            </ul></li>
                        </ul>
                    </section>
                    <section>
                        <h2>Migrating Models Across Apps with South</h2>
                        <p>If the project is pre-production, you can get away with automatic schema migrations.  Otherwise, this is a multi-step process.</p>
                        <ul>
                            <li><em>Copy</em> the model the new app, create a schema migration.</li>
                            <li><em>Delete</em> the old model, create a <em>separate</em> schema migration.</li>
                            <li><em>Modify</em> your migration for creating the table to perform a <em>rename</em> operation.<ul>
                                <li><pre><code>
def forwards(self, orm):
    #db.delete_table('oldapp_mymodel', 'newapp_mymodel') 
    db.rename_table('oldapp_mymodel', 'newapp_mymodel') 

def backwards(self, orm):
    # db.create_table(u'oldapp_mymodel', (
    #     ('description', self.gf('django.db.models.fields.TextField')()),
    #     (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
    # ))
    
    db.rename_table('newapp_mymodel', 'oldapp_mymodel')
    
                                </code></pre></li>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Migrating Models Across Apps with South (continued)</h2>
                        <ul>
                            <li><em>Modify</em> the migration for deleting the old model to <em>depend on</em> your rename migration.
                                <pre><code>
class Migration(SchemaMigration):
    depends_on = (('newapp', '0001_initial'),)
    
    def forward(self):
        pass
        
    def backward(self):
        pass
                                </code></pre>
                            </li>
                            <li>Take extra care with ContentTypes and relationships.</li>
                        </ul>
                        <br><br>
                        <p>A great discussion of these techniques is on StackOverflow:  <a href="http://stackoverflow.com/questions/1258130/how-do-i-migrate-a-model-out-of-one-django-app-and-into-a-new-one">http://stackoverflow.com/questions/1258130/how-do-i-migrate-a-model-out-of-one-django-app-and-into-a-new-one</a></p>
                    </section>
                    <section>
                        <h2>Migrating Models Across Apps with Django Migrations</h2>
                        <p>Using Django 1.7's migrations is a little more tricky because migrations.RenameModel only takes a model name, and not the app label for the table.</p>
                        <p>Your best bet is to simply create the new models and write a separate data migration to copy old data to the new tables before deleting the original models.</p>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>The "Every Model is an App" Project</h2>
                        <p>"I like my INSTALLED_APPS to be a list of database tables."</p>
                    </section>
                    <section>
                        <h2>The "Every Model is an App" Project</h2>
                        <p>This type of structure is another organizational nightmare, for similar reasons to a monolith but due to an opposite cause.</p>
                        <ul>
                            <li>You cannot succinctly evaluate the functionality of any one component.</li>
                            <li>Nothing is portable.</li>
                            <li>You'll get very acquainted with:<pre><code>
Traceback (most recent call last):
  ...
  File "/app1/foo.py", line 1, in &lt;module&gt;
    from app2 import bar
  File "/app2/bar.py", line 1, in &lt;module&gt;
    from app1 import foo
ImportError: cannot import name foo   
                            </pre></code></li>
                        </ul>
                    </section>
                    <section>
                        <h2>The "Every Model is an App" Project</h2>
                        <p>Follow the same steps as a monolith.  The challenges are the same; creating an organized structure and migrating models across apps into their new home, and everything else follows.</p>
                        <p>This should be less work than a monolith, as one of your apps will become the 'host' for others.</p>
                        
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Receivers Everywhere!</h2>
                        <p>Decoupling every single model since 2003.</p>
                    </section>
                    <section>
                        <h2>Signals/Receivers Are Useful</h2>
                        <ul>
                            <li>Signals allow for a decoupling of models that need side effects.</li>
                            <li>They are especially useful for triggering side effects in 3rd party code.</li>
                        </ul>
                    </section>
                    <section>
                        <h2>... But Not Always</h2>
                        <ul>
                            <li>Signals can hide important functionality from developers.</li>
                            <li>Signals are often unnecessary abstraction between two models in the same application.</li>
                            <li>Signal receivers can implement over-zealous business logic.</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Getting Rid of Superfluous Signal Receivers</h2>
                        <p>Be on the lookout for:</p>
                        <ul>
                            <li>Signal receivers that interact between two database related models.</li>
                            <li>Signal receivers in which the instance simply operates on itself.</li>
                            <li>Signal receivers that implement transactional/business logic.</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>The "How Did I Live Without Context Processors/Middleware?" Project</h2>
                        <p>Taking DRY to the Max</p>
                    </section>
                    <section>
                        <h3>... (reminds me of when I discovered list comprehensions in Python)</h3>
                        <pre><code>
def publish_all():
    # NOT SURE WHY IM DOING THIS
    # BUT IT IS COOL AS HELL!
    [p.publish() for p in Post.objects.all()]                                    
                        </code></pre>
                    </section>
                    <section>
                        <h2>Context Processors</h2>
                        <p>Context Processors are widely abused and can quickly impair performance.  You should evaluate each context processor in the project and see if:</p>
                    </section>
                    <section>
                        <ul>
                            <li class="unstyled">1. The context processor is better suited as a templatetag.

                                <pre><code>
# in myapp.context_processors.py                                

from myapp.utils import products_by_category
def products(request):
    return {'products_by_category': products_by_category()}
                                </code></pre>
                                <pre><code>
# in myapp.templatetags           

from django import template
from myapp.utils import products_by_category

register = template.Library()

@register.assignment_tag(takes_context=True)
def get_products_by_category(context):
    return products_by_category()
                                </code></pre>
                            </li>
                        </ul>
                        <p class="green">Assignment Tags are effective here.</p>
                    </section>
                    <section>
                        <ul>
                            <li class="unstyled">2. The context processor logic should be refactored into relevant views.
                                <pre><code>
# in myapp.context_processors.py                                

from myapp.utils import products_by_category
def products(request):
    return {'products_by_category': products_by_category()}
                                </code></pre>
                                <pre><code>
# in myapp.views

from myapp.utils import products_by_category

class MyView(DetailView):

    def get_context_data(self, **kwargs):
        context = super(MyView, self).get_context_data(kwargs)
        context.update({'products_by_category': products_by_category()})
        
        return context
                                </code></pre>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Middleware</h2>
                        <p>Not as widely abused as Context Processors, but potentially have larger performance implications.</p>
                        <p class="fragment red">Do I need this logic to execute on <em>every single request and/or response?</em></p>
                        <p class="fragment">If not, you should engineer a way around.</em></p>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>The Undocumented Black Box Full of Black Boxes</h2>
                        <p># Who put all these hashtags in my code?</p>
                    </section>
                    <section>
                        <p>The only thing worse than code with no comments...</p>
                        <pre><code>
def get_classification(self):
    if self.classification and len(self.classification) == 2:
        level = CLASSIFICATIONS.get(self.classification[0], '')
        class_level = self.classification[1]
        if class_level == 'U':
            class_level = ''
        else:
            class_level = 'class %s '%class_level
        string = '%s%s'%(class_level, level)
        return dict({'level':level, 'class': class_level, 'string':string,})
    else:
        return None
                        </code></pre>
                    </section>
                    <section> 
                        <p>... is code with just enough comments to piss you off</p>
                        <pre><code>
def get_classification(self):
    if self.classification and len(self.classification) == 2:
        level = CLASSIFICATIONS.get(self.classification[0], '')
        class_level = self.classification[1]
        if class_level == 'U':
            class_level = ''
        else:
            class_level = 'class %s '%class_level
        string = '%s%s'%(class_level, level)
        # returns dict
        return dict({'level':level, 'class': class_level, 'string':string,})
    else:
        return None
                        </code></pre>
                </section>
                <section>
                    <h2>There's No Easy Way Out of Undocumented Code</h2>
                    <p>You could try and brute force your way through it, but that's impractical.</p>
                </section>
                <section>
                    <h2>Document as You Go</h2>
                    <p>Make it policy:  If you edit the code, you document the code.  If you have to dissect code to understand it, comment what you find.</p>
                </section>
                <section>
                    <h2>Document as You Go</h2>
                    <ul>
                        <li>
                            Every module, function, class, and method get a docstring.  No exceptions!
                            <ul>
                                <li>These are the workhorses of your documentation effort.</li>
                            </ul>
                        </li>
                        <li>Break apart long, multi-step logical branches with comments.</li>
                        <li>If a statement is difficult read or has some sort of ambiguity, leave a comment!
                            <pre><code>
                            </code></pre>
                        </li>
                    </ul>
                </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
